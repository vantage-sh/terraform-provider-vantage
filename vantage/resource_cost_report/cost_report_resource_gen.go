// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_cost_report

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func CostReportResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"business_metric_tokens_with_metadata": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"business_metric_token": schema.StringAttribute{
							Required:            true,
							Description:         "The token of the BusinessMetric to attach to the CostReport.",
							MarkdownDescription: "The token of the BusinessMetric to attach to the CostReport.",
						},
						"label_filter": schema.ListAttribute{
							ElementType:         types.StringType,
							Optional:            true,
							Computed:            true,
							Description:         "Include only values with these labels in the CostReport.",
							MarkdownDescription: "Include only values with these labels in the CostReport.",
						},
						"unit_scale": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Determines the scale of the BusinessMetric's values within the CostReport.",
							MarkdownDescription: "Determines the scale of the BusinessMetric's values within the CostReport.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"per_unit",
									"per_hundred",
									"per_thousand",
									"per_million",
									"per_billion",
								),
							},
							Default: stringdefault.StaticString("per_unit"),
						},
					},
					CustomType: BusinessMetricTokensWithMetadataType{
						ObjectType: types.ObjectType{
							AttrTypes: BusinessMetricTokensWithMetadataValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The tokens for any BusinessMetrics to attach to the CostReport, and the unit scale.",
				MarkdownDescription: "The tokens for any BusinessMetrics to attach to the CostReport, and the unit scale.",
			},
			"chart_type": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The chart type of the CostReport.",
				MarkdownDescription: "The chart type of the CostReport.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"area",
						"line",
						"pie",
						"bar",
					),
				},
				Default: stringdefault.StaticString("line"),
			},
			"created_at": schema.StringAttribute{
				Computed:            true,
				Description:         "The date and time, in UTC, the report was created. ISO 8601 Formatted.",
				MarkdownDescription: "The date and time, in UTC, the report was created. ISO 8601 Formatted.",
			},
			"date_bin": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The date bin of the CostReport.",
				MarkdownDescription: "The date bin of the CostReport.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"cumulative",
						"day",
						"week",
						"month",
					),
				},
				Default: stringdefault.StaticString("cumulative"),
			},
			"date_interval": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The date interval of the CostReport. Incompatible with 'start_date' and 'end_date' parameters. Defaults to 'this_month' if start_date and end_date are not provided.",
				MarkdownDescription: "The date interval of the CostReport. Incompatible with 'start_date' and 'end_date' parameters. Defaults to 'this_month' if start_date and end_date are not provided.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"this_month",
						"last_7_days",
						"last_30_days",
						"last_month",
						"last_3_months",
						"last_6_months",
						"custom",
						"last_12_months",
						"last_24_months",
						"last_36_months",
						"next_month",
						"next_3_months",
						"next_6_months",
						"next_12_months",
						"year_to_date",
						"last_3_days",
					),
				},
			},
			"end_date": schema.StringAttribute{
				Required:            true,
				Description:         "The end date of the CostReport. ISO 8601 Formatted. Incompatible with 'date_interval' parameter.",
				MarkdownDescription: "The end date of the CostReport. ISO 8601 Formatted. Incompatible with 'date_interval' parameter.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The filter query language to apply to the CostReport. Additional documentation available at https://docs.vantage.sh/vql.",
				MarkdownDescription: "The filter query language to apply to the CostReport. Additional documentation available at https://docs.vantage.sh/vql.",
			},
			"folder_token": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The token of the Folder to add the CostReport to. Determines the Workspace the report is assigned to.",
				MarkdownDescription: "The token of the Folder to add the CostReport to. Determines the Workspace the report is assigned to.",
			},
			"groupings": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Grouping values for aggregating costs on the report. Valid groupings: account_id, billing_account_id, charge_type, cost_category, cost_subcategory, provider, region, resource_id, service, tagged, tag:<tag_value>. If providing multiple groupings, join as comma separated values: groupings=provider,service,region",
				MarkdownDescription: "Grouping values for aggregating costs on the report. Valid groupings: account_id, billing_account_id, charge_type, cost_category, cost_subcategory, provider, region, resource_id, service, tagged, tag:<tag_value>. If providing multiple groupings, join as comma separated values: groupings=provider,service,region",
			},
			"previous_period_end_date": schema.StringAttribute{
				Required:            true,
				Description:         "The previous period end date of the CostReport. ISO 8601 Formatted.",
				MarkdownDescription: "The previous period end date of the CostReport. ISO 8601 Formatted.",
			},
			"previous_period_start_date": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The previous period start date of the CostReport. ISO 8601 Formatted.",
				MarkdownDescription: "The previous period start date of the CostReport. ISO 8601 Formatted.",
			},
			"saved_filter_tokens": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "The tokens of the SavedFilters to apply to the CostReport.",
				MarkdownDescription: "The tokens of the SavedFilters to apply to the CostReport.",
			},
			"settings": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aggregate_by": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will aggregate by cost or usage.",
						MarkdownDescription: "Report will aggregate by cost or usage.",
						Default:             stringdefault.StaticString("cost"),
					},
					"amortize": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will amortize.",
						MarkdownDescription: "Report will amortize.",
						Default:             booldefault.StaticBool(true),
					},
					"include_credits": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will include credits.",
						MarkdownDescription: "Report will include credits.",
						Default:             booldefault.StaticBool(false),
					},
					"include_discounts": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will include discounts.",
						MarkdownDescription: "Report will include discounts.",
						Default:             booldefault.StaticBool(true),
					},
					"include_refunds": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will include refunds.",
						MarkdownDescription: "Report will include refunds.",
						Default:             booldefault.StaticBool(false),
					},
					"include_tax": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will include tax.",
						MarkdownDescription: "Report will include tax.",
						Default:             booldefault.StaticBool(true),
					},
					"unallocated": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Report will show unallocated costs.",
						MarkdownDescription: "Report will show unallocated costs.",
						Default:             booldefault.StaticBool(false),
					},
				},
				CustomType: SettingsType{
					ObjectType: types.ObjectType{
						AttrTypes: SettingsValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Report settings.",
				MarkdownDescription: "Report settings.",
			},
			"start_date": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The start date of the CostReport. ISO 8601 Formatted. Incompatible with 'date_interval' parameter.",
				MarkdownDescription: "The start date of the CostReport. ISO 8601 Formatted. Incompatible with 'date_interval' parameter.",
			},
			"title": schema.StringAttribute{
				Required:            true,
				Description:         "The title of the CostReport.",
				MarkdownDescription: "The title of the CostReport.",
			},
			"token": schema.StringAttribute{
				Computed:            true,
				Description:         "The token of the cost report",
				MarkdownDescription: "The token of the cost report",
			},
			"workspace_token": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The token of the Workspace to add the Cost Report to. Ignored if 'folder_token' is set. Required if the API token is associated with multiple Workspaces.",
				MarkdownDescription: "The token of the Workspace to add the Cost Report to. Ignored if 'folder_token' is set. Required if the API token is associated with multiple Workspaces.",
			},
		},
	}
}

type CostReportModel struct {
	BusinessMetricTokensWithMetadata types.List    `tfsdk:"business_metric_tokens_with_metadata"`
	ChartType                        types.String  `tfsdk:"chart_type"`
	CreatedAt                        types.String  `tfsdk:"created_at"`
	DateBin                          types.String  `tfsdk:"date_bin"`
	DateInterval                     types.String  `tfsdk:"date_interval"`
	EndDate                          types.String  `tfsdk:"end_date"`
	Filter                           types.String  `tfsdk:"filter"`
	FolderToken                      types.String  `tfsdk:"folder_token"`
	Groupings                        types.String  `tfsdk:"groupings"`
	PreviousPeriodEndDate            types.String  `tfsdk:"previous_period_end_date"`
	PreviousPeriodStartDate          types.String  `tfsdk:"previous_period_start_date"`
	SavedFilterTokens                types.List    `tfsdk:"saved_filter_tokens"`
	Settings                         SettingsValue `tfsdk:"settings"`
	StartDate                        types.String  `tfsdk:"start_date"`
	Title                            types.String  `tfsdk:"title"`
	Token                            types.String  `tfsdk:"token"`
	WorkspaceToken                   types.String  `tfsdk:"workspace_token"`
}

var _ basetypes.ObjectTypable = BusinessMetricTokensWithMetadataType{}

type BusinessMetricTokensWithMetadataType struct {
	basetypes.ObjectType
}

func (t BusinessMetricTokensWithMetadataType) Equal(o attr.Type) bool {
	other, ok := o.(BusinessMetricTokensWithMetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BusinessMetricTokensWithMetadataType) String() string {
	return "BusinessMetricTokensWithMetadataType"
}

func (t BusinessMetricTokensWithMetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	businessMetricTokenAttribute, ok := attributes["business_metric_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`business_metric_token is missing from object`)

		return nil, diags
	}

	businessMetricTokenVal, ok := businessMetricTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`business_metric_token expected to be basetypes.StringValue, was: %T`, businessMetricTokenAttribute))
	}

	labelFilterAttribute, ok := attributes["label_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label_filter is missing from object`)

		return nil, diags
	}

	labelFilterVal, ok := labelFilterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label_filter expected to be basetypes.ListValue, was: %T`, labelFilterAttribute))
	}

	unitScaleAttribute, ok := attributes["unit_scale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_scale is missing from object`)

		return nil, diags
	}

	unitScaleVal, ok := unitScaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_scale expected to be basetypes.StringValue, was: %T`, unitScaleAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BusinessMetricTokensWithMetadataValue{
		BusinessMetricToken: businessMetricTokenVal,
		LabelFilter:         labelFilterVal,
		UnitScale:           unitScaleVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewBusinessMetricTokensWithMetadataValueNull() BusinessMetricTokensWithMetadataValue {
	return BusinessMetricTokensWithMetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewBusinessMetricTokensWithMetadataValueUnknown() BusinessMetricTokensWithMetadataValue {
	return BusinessMetricTokensWithMetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBusinessMetricTokensWithMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BusinessMetricTokensWithMetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BusinessMetricTokensWithMetadataValue Attribute Value",
				"While creating a BusinessMetricTokensWithMetadataValue value, a missing attribute value was detected. "+
					"A BusinessMetricTokensWithMetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BusinessMetricTokensWithMetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BusinessMetricTokensWithMetadataValue Attribute Type",
				"While creating a BusinessMetricTokensWithMetadataValue value, an invalid attribute value was detected. "+
					"A BusinessMetricTokensWithMetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BusinessMetricTokensWithMetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BusinessMetricTokensWithMetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BusinessMetricTokensWithMetadataValue Attribute Value",
				"While creating a BusinessMetricTokensWithMetadataValue value, an extra attribute value was detected. "+
					"A BusinessMetricTokensWithMetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BusinessMetricTokensWithMetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBusinessMetricTokensWithMetadataValueUnknown(), diags
	}

	businessMetricTokenAttribute, ok := attributes["business_metric_token"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`business_metric_token is missing from object`)

		return NewBusinessMetricTokensWithMetadataValueUnknown(), diags
	}

	businessMetricTokenVal, ok := businessMetricTokenAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`business_metric_token expected to be basetypes.StringValue, was: %T`, businessMetricTokenAttribute))
	}

	labelFilterAttribute, ok := attributes["label_filter"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`label_filter is missing from object`)

		return NewBusinessMetricTokensWithMetadataValueUnknown(), diags
	}

	labelFilterVal, ok := labelFilterAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`label_filter expected to be basetypes.ListValue, was: %T`, labelFilterAttribute))
	}

	unitScaleAttribute, ok := attributes["unit_scale"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unit_scale is missing from object`)

		return NewBusinessMetricTokensWithMetadataValueUnknown(), diags
	}

	unitScaleVal, ok := unitScaleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unit_scale expected to be basetypes.StringValue, was: %T`, unitScaleAttribute))
	}

	if diags.HasError() {
		return NewBusinessMetricTokensWithMetadataValueUnknown(), diags
	}

	return BusinessMetricTokensWithMetadataValue{
		BusinessMetricToken: businessMetricTokenVal,
		LabelFilter:         labelFilterVal,
		UnitScale:           unitScaleVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewBusinessMetricTokensWithMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BusinessMetricTokensWithMetadataValue {
	object, diags := NewBusinessMetricTokensWithMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBusinessMetricTokensWithMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BusinessMetricTokensWithMetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBusinessMetricTokensWithMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBusinessMetricTokensWithMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBusinessMetricTokensWithMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBusinessMetricTokensWithMetadataValueMust(BusinessMetricTokensWithMetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BusinessMetricTokensWithMetadataType) ValueType(ctx context.Context) attr.Value {
	return BusinessMetricTokensWithMetadataValue{}
}

var _ basetypes.ObjectValuable = BusinessMetricTokensWithMetadataValue{}

type BusinessMetricTokensWithMetadataValue struct {
	BusinessMetricToken basetypes.StringValue `tfsdk:"business_metric_token"`
	LabelFilter         basetypes.ListValue   `tfsdk:"label_filter"`
	UnitScale           basetypes.StringValue `tfsdk:"unit_scale"`
	state               attr.ValueState
}

func (v BusinessMetricTokensWithMetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["business_metric_token"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["label_filter"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["unit_scale"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.BusinessMetricToken.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["business_metric_token"] = val

		val, err = v.LabelFilter.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["label_filter"] = val

		val, err = v.UnitScale.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unit_scale"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BusinessMetricTokensWithMetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BusinessMetricTokensWithMetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BusinessMetricTokensWithMetadataValue) String() string {
	return "BusinessMetricTokensWithMetadataValue"
}

func (v BusinessMetricTokensWithMetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var labelFilterVal basetypes.ListValue
	switch {
	case v.LabelFilter.IsUnknown():
		labelFilterVal = types.ListUnknown(types.StringType)
	case v.LabelFilter.IsNull():
		labelFilterVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelFilterVal, d = types.ListValue(types.StringType, v.LabelFilter.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"business_metric_token": basetypes.StringType{},
			"label_filter": basetypes.ListType{
				ElemType: types.StringType,
			},
			"unit_scale": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"business_metric_token": basetypes.StringType{},
		"label_filter": basetypes.ListType{
			ElemType: types.StringType,
		},
		"unit_scale": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"business_metric_token": v.BusinessMetricToken,
			"label_filter":          labelFilterVal,
			"unit_scale":            v.UnitScale,
		})

	return objVal, diags
}

func (v BusinessMetricTokensWithMetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(BusinessMetricTokensWithMetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BusinessMetricToken.Equal(other.BusinessMetricToken) {
		return false
	}

	if !v.LabelFilter.Equal(other.LabelFilter) {
		return false
	}

	if !v.UnitScale.Equal(other.UnitScale) {
		return false
	}

	return true
}

func (v BusinessMetricTokensWithMetadataValue) Type(ctx context.Context) attr.Type {
	return BusinessMetricTokensWithMetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BusinessMetricTokensWithMetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"business_metric_token": basetypes.StringType{},
		"label_filter": basetypes.ListType{
			ElemType: types.StringType,
		},
		"unit_scale": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SettingsType{}

type SettingsType struct {
	basetypes.ObjectType
}

func (t SettingsType) Equal(o attr.Type) bool {
	other, ok := o.(SettingsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SettingsType) String() string {
	return "SettingsType"
}

func (t SettingsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggregateByAttribute, ok := attributes["aggregate_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregate_by is missing from object`)

		return nil, diags
	}

	aggregateByVal, ok := aggregateByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregate_by expected to be basetypes.StringValue, was: %T`, aggregateByAttribute))
	}

	amortizeAttribute, ok := attributes["amortize"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amortize is missing from object`)

		return nil, diags
	}

	amortizeVal, ok := amortizeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amortize expected to be basetypes.BoolValue, was: %T`, amortizeAttribute))
	}

	includeCreditsAttribute, ok := attributes["include_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_credits is missing from object`)

		return nil, diags
	}

	includeCreditsVal, ok := includeCreditsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_credits expected to be basetypes.BoolValue, was: %T`, includeCreditsAttribute))
	}

	includeDiscountsAttribute, ok := attributes["include_discounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_discounts is missing from object`)

		return nil, diags
	}

	includeDiscountsVal, ok := includeDiscountsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_discounts expected to be basetypes.BoolValue, was: %T`, includeDiscountsAttribute))
	}

	includeRefundsAttribute, ok := attributes["include_refunds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_refunds is missing from object`)

		return nil, diags
	}

	includeRefundsVal, ok := includeRefundsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_refunds expected to be basetypes.BoolValue, was: %T`, includeRefundsAttribute))
	}

	includeTaxAttribute, ok := attributes["include_tax"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_tax is missing from object`)

		return nil, diags
	}

	includeTaxVal, ok := includeTaxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_tax expected to be basetypes.BoolValue, was: %T`, includeTaxAttribute))
	}

	unallocatedAttribute, ok := attributes["unallocated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unallocated is missing from object`)

		return nil, diags
	}

	unallocatedVal, ok := unallocatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unallocated expected to be basetypes.BoolValue, was: %T`, unallocatedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SettingsValue{
		AggregateBy:      aggregateByVal,
		Amortize:         amortizeVal,
		IncludeCredits:   includeCreditsVal,
		IncludeDiscounts: includeDiscountsVal,
		IncludeRefunds:   includeRefundsVal,
		IncludeTax:       includeTaxVal,
		Unallocated:      unallocatedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSettingsValueNull() SettingsValue {
	return SettingsValue{
		state: attr.ValueStateNull,
	}
}

func NewSettingsValueUnknown() SettingsValue {
	return SettingsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSettingsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SettingsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SettingsValue Attribute Value",
				"While creating a SettingsValue value, a missing attribute value was detected. "+
					"A SettingsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SettingsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SettingsValue Attribute Type",
				"While creating a SettingsValue value, an invalid attribute value was detected. "+
					"A SettingsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SettingsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SettingsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SettingsValue Attribute Value",
				"While creating a SettingsValue value, an extra attribute value was detected. "+
					"A SettingsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SettingsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSettingsValueUnknown(), diags
	}

	aggregateByAttribute, ok := attributes["aggregate_by"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregate_by is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	aggregateByVal, ok := aggregateByAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregate_by expected to be basetypes.StringValue, was: %T`, aggregateByAttribute))
	}

	amortizeAttribute, ok := attributes["amortize"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`amortize is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	amortizeVal, ok := amortizeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`amortize expected to be basetypes.BoolValue, was: %T`, amortizeAttribute))
	}

	includeCreditsAttribute, ok := attributes["include_credits"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_credits is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	includeCreditsVal, ok := includeCreditsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_credits expected to be basetypes.BoolValue, was: %T`, includeCreditsAttribute))
	}

	includeDiscountsAttribute, ok := attributes["include_discounts"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_discounts is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	includeDiscountsVal, ok := includeDiscountsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_discounts expected to be basetypes.BoolValue, was: %T`, includeDiscountsAttribute))
	}

	includeRefundsAttribute, ok := attributes["include_refunds"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_refunds is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	includeRefundsVal, ok := includeRefundsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_refunds expected to be basetypes.BoolValue, was: %T`, includeRefundsAttribute))
	}

	includeTaxAttribute, ok := attributes["include_tax"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`include_tax is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	includeTaxVal, ok := includeTaxAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`include_tax expected to be basetypes.BoolValue, was: %T`, includeTaxAttribute))
	}

	unallocatedAttribute, ok := attributes["unallocated"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unallocated is missing from object`)

		return NewSettingsValueUnknown(), diags
	}

	unallocatedVal, ok := unallocatedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unallocated expected to be basetypes.BoolValue, was: %T`, unallocatedAttribute))
	}

	if diags.HasError() {
		return NewSettingsValueUnknown(), diags
	}

	return SettingsValue{
		AggregateBy:      aggregateByVal,
		Amortize:         amortizeVal,
		IncludeCredits:   includeCreditsVal,
		IncludeDiscounts: includeDiscountsVal,
		IncludeRefunds:   includeRefundsVal,
		IncludeTax:       includeTaxVal,
		Unallocated:      unallocatedVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSettingsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SettingsValue {
	object, diags := NewSettingsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSettingsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SettingsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSettingsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSettingsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSettingsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSettingsValueMust(SettingsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SettingsType) ValueType(ctx context.Context) attr.Value {
	return SettingsValue{}
}

var _ basetypes.ObjectValuable = SettingsValue{}

type SettingsValue struct {
	AggregateBy      basetypes.StringValue `tfsdk:"aggregate_by"`
	Amortize         basetypes.BoolValue   `tfsdk:"amortize"`
	IncludeCredits   basetypes.BoolValue   `tfsdk:"include_credits"`
	IncludeDiscounts basetypes.BoolValue   `tfsdk:"include_discounts"`
	IncludeRefunds   basetypes.BoolValue   `tfsdk:"include_refunds"`
	IncludeTax       basetypes.BoolValue   `tfsdk:"include_tax"`
	Unallocated      basetypes.BoolValue   `tfsdk:"unallocated"`
	state            attr.ValueState
}

func (v SettingsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["aggregate_by"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["amortize"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["include_credits"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["include_discounts"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["include_refunds"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["include_tax"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["unallocated"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AggregateBy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregate_by"] = val

		val, err = v.Amortize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["amortize"] = val

		val, err = v.IncludeCredits.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_credits"] = val

		val, err = v.IncludeDiscounts.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_discounts"] = val

		val, err = v.IncludeRefunds.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_refunds"] = val

		val, err = v.IncludeTax.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["include_tax"] = val

		val, err = v.Unallocated.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unallocated"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SettingsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SettingsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SettingsValue) String() string {
	return "SettingsValue"
}

func (v SettingsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"aggregate_by":      basetypes.StringType{},
		"amortize":          basetypes.BoolType{},
		"include_credits":   basetypes.BoolType{},
		"include_discounts": basetypes.BoolType{},
		"include_refunds":   basetypes.BoolType{},
		"include_tax":       basetypes.BoolType{},
		"unallocated":       basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"aggregate_by":      v.AggregateBy,
			"amortize":          v.Amortize,
			"include_credits":   v.IncludeCredits,
			"include_discounts": v.IncludeDiscounts,
			"include_refunds":   v.IncludeRefunds,
			"include_tax":       v.IncludeTax,
			"unallocated":       v.Unallocated,
		})

	return objVal, diags
}

func (v SettingsValue) Equal(o attr.Value) bool {
	other, ok := o.(SettingsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AggregateBy.Equal(other.AggregateBy) {
		return false
	}

	if !v.Amortize.Equal(other.Amortize) {
		return false
	}

	if !v.IncludeCredits.Equal(other.IncludeCredits) {
		return false
	}

	if !v.IncludeDiscounts.Equal(other.IncludeDiscounts) {
		return false
	}

	if !v.IncludeRefunds.Equal(other.IncludeRefunds) {
		return false
	}

	if !v.IncludeTax.Equal(other.IncludeTax) {
		return false
	}

	if !v.Unallocated.Equal(other.Unallocated) {
		return false
	}

	return true
}

func (v SettingsValue) Type(ctx context.Context) attr.Type {
	return SettingsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SettingsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggregate_by":      basetypes.StringType{},
		"amortize":          basetypes.BoolType{},
		"include_credits":   basetypes.BoolType{},
		"include_discounts": basetypes.BoolType{},
		"include_refunds":   basetypes.BoolType{},
		"include_tax":       basetypes.BoolType{},
		"unallocated":       basetypes.BoolType{},
	}
}
